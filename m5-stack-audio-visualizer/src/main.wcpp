#include <limits.h>
#include <Arduino.h>
#include <arduinoFFT.h>
#include <M5GFX.h>
#include "simple_ui.h"

// ---------------------------------------------------
#define ADC_PIN ADC2
#define SAMPLES 512              // Must be a power of 2
#define SAMPLING_FREQUENCY 40000 // Hz, must be 40000 or less due to ADC conversion time. Determines maximum frequency that can be analysed by the FFT Fmax=sampleF/2.

struct eqBand {
  const char *freqname;
  uint16_t amplitude;
  int peak;
  int lastpeak;
  uint16_t lastval;
  unsigned long lastmeasured;
};
 
eqBand audiospectrum[9] = {
  //Adjust the amplitude values to fit your microphone
  { "125Hz", 500, 0, 0, 0, 0},
  { "250Hz", 200, 0, 0, 0, 0},
  { "500Hz", 200, 0, 0, 0, 0},
  { "1KHz",  200, 0, 0, 0, 0},
  { "2KHz",  200, 0, 0, 0, 0},
  { "4KHz",  100, 0, 0, 0, 0},
  { "6k3",   100, 0, 0, 0, 0},
  { "10KHz", 100, 0, 0, 0, 0},
  { "16KHz", 50,  0, 0, 0, 0}
};

unsigned int sampling_period_us;
unsigned long microseconds;
double vReal[SAMPLES];
double vImag[SAMPLES];
unsigned long newTime, oldTime;
uint16_t tft_width  = 320; // ILI9341_TFTWIDTH;
uint16_t tft_height = 240; // ILI9341_TFTHEIGHT;
uint8_t bands = 8;
uint8_t bands_width = floor( tft_width / bands );
uint8_t bands_pad = bands_width - 10;
uint16_t colormap[255]; // color palette for the band meter (pre-fill in setup)

// ---------------------------------------------------

// void displayBand(int band, int dsize)
// {
//   int dmax = 50;

//   if (dsize > dmax) 
//   	dsize = dmax;

// //   if (band == 7) 
// //   	display.drawHorizontalLine(18*6,0, 14);

// //   for (int s = 0; s <= dsize; s=s+2)
// //   	display.drawHorizontalLine(18*band,64-s, 14);

//   // if (dsize > peak[band]) 
//   // 	peak[band] = dsize;
// }

byte getBand(int i) {
  if (i<=2 )             return 0;  // 125Hz
  if (i >3   && i<=5 )   return 1;  // 250Hz
  if (i >5   && i<=7 )   return 2;  // 500Hz
  if (i >7   && i<=15 )  return 3;  // 1000Hz
  if (i >15  && i<=30 )  return 4;  // 2000Hz
  if (i >30  && i<=53 )  return 5;  // 4000Hz
  if (i >53  && i<=200 ) return 6;  // 8000Hz
  if (i >200           ) return 7;  // 16000Hz
  return 8;
}



void displayBand(int band, int dsize){

  uint16_t hpos = bands_width*band;

  int dmax = 60; // 200;

  // if(dsize>tft_height-10) {
  //   dsize = tft_height-10; // leave some hspace for text
  // }
  
  if(dsize < audiospectrum[band].lastval) {
    // lower value, delete some lines
   // analyzer.Update(band, audiospectrum[band].lastval);

    // M5.Lcd.fillRect(hpos, tft_height-audiospectrum[band].lastval,
    //                 bands_pad, audiospectrum[band].lastval - dsize, BLACK);
  }

  if (dsize > dmax) dsize = dmax;

  for (int s = 0; s <= dsize; s=s+4){
    //M5.Lcd.drawFastHLine(hpos, tft_height-s, bands_pad, colormap[tft_height-s]);
  }

  if (dsize > audiospectrum[band].peak) {
    audiospectrum[band].peak = dsize;
  }

  audiospectrum[band].lastval = dsize;
  audiospectrum[band].lastmeasured = millis();
}

M5GFX display;
arduinoFFT fft;

void setup() {


  
	sampling_period_us = round(1000000 * (1.0 / SAMPLING_FREQUENCY));

  display.init();
  display.startWrite();
  display.fillScreen(TFT_RED);

  if (display.isEPD())
  {
    display.setEpdMode(epd_mode_t::epd_fastest);
  }
  if (display.width() < display.height())
  {
    display.setRotation(display.getRotation() ^ 1);
  }

  display.waitDisplay();
  
  // UI
  display.setTextColor(TFT_WHITE);
  display.setFont(&fonts::Font2);

  // Title
  display.drawString("S/PDIF", 100, 0);

  // Main

	//UISoundAnalyzer<8> analyzer({ 30, 25, 270, 120 });
  const uint8_t bands_count = 30;
  uint8_t bands[bands_count];

  for(auto i = 0; i<bands_count; i++)
  {
    bands[i] = 0;
  }

  render_analyzer_ui(display, 0, 25, 320, 120, bands_count, bands);

  // Levels
  // UILabel level_left_label({ 0, 181, 20, 16 }, "L", font, 16);
  // UILabel level_right_label({ 0, 181 + 13 + 3, 20, 16 }, "R", font, 16);

  // UVProgress<uint16_t> level_left({ 24, 181, 244, 13 }, 0, 4095, 4095 * 0.9, 0);
  // UVProgress<uint16_t> level_right({ 24, 181 + 13 + 3, 244, 13 }, 2000, 4095, 4095 * 0.9, 0);

  // Footer
  auto bgcolor = display.color888(56, 56, 56);
  display.fillRect(0, 240-23,320, 23, bgcolor);

  // Build UI
  display.endWrite();
  display.display();
  uint16_t l_value = 0;
  uint16_t r_level = 0;

  while (true)
	{
    uint64_t sum = 0;

		for (int i = 0; i < SAMPLES; i++) 
		{
			newTime = micros()-oldTime;
			oldTime = newTime;

			vReal[i] = analogRead(ADC_PIN); // A conversion takes about 1uS on an ESP32

      sum += vReal[i];
			vImag[i] = 0;

			while (micros() < (newTime + sampling_period_us));
		}

		fft.Windowing(vReal, SAMPLES, FFT_WIN_TYP_HAMMING, FFT_FORWARD);
		fft.Compute(vReal, vImag, SAMPLES, FFT_FORWARD);
		fft.ComplexToMagnitude(vReal, vImag, SAMPLES);

    // for (int i = 2; i < (SAMPLES/2); i++){ 
    //   // Don't use sample 0 and only first SAMPLES/2 are usable. 
    //   // Each array eleement represents a frequency and its value the amplitude.
    //   if (vReal[i] > 1500) { // Add a crude noise filter, 10 x amplitude or more
    //     byte bandNum = getBand(i);
    //     if(bandNum!=8) {
    //       displayBand(analyzer, bandNum, (int)vReal[i]/audiospectrum[bandNum].amplitude);
    //     }
    //   }
    // }

    // long vnow = millis();
    // for (byte band = 0; band <= 7; band++) {
    //   // auto decay every 50ms on low activity bands
    //   if(vnow - audiospectrum[band].lastmeasured > 50) {
    //     displayBand(analyzer, band, audiospectrum[band].lastval>4 ? audiospectrum[band].lastval-4 : 0);
    //   }

    //   // if (audiospectrum[band].peak > 0) {
    //   //   audiospectrum[band].peak -= 2;
    //   //   if(audiospectrum[band].peak<=0) {
    //   //     audiospectrum[band].peak = 0;
    //   //   }
    //   // }
    //   // only draw if peak changed
    //   // if(audiospectrum[band].lastpeak != audiospectrum[band].peak) {
    //   //   // delete last peak
    //   // //M5.Lcd.drawFastHLine(bands_width*band,tft_height-audiospectrum[band].lastpeak,bands_pad,BLACK);
    //   // audiospectrum[band].lastpeak = audiospectrum[band].peak;
    //   // //  M5.Lcd.drawFastHLine(bands_width*band, tft_height-audiospectrum[band].peak,
    //   // //                        bands_pad, colormap[tft_height-audiospectrum[band].peak]);
    //   // }
    // } 

   // l_value = sum / SAMPLES;

	//	level_left.Set(l_value);
	//	level_right.Set(r_level);


    

		delay(100);
	}
}



void loop() {
  // put your main code here, to run repeatedly:
  delay(10);
}